<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/Widget.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/Widget.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { useCallback, useEffect, useState } from "react";
import { Sortable, Plugins } from "@shopify/draggable";

import { WidgetDataItem } from "../types";

import Modal from "./Modal";
import WidgetItemRow from "./WidgetItemRow";

import useCollectionAPI from "../hooks/useCollectionAPI";
import useCollectionItems from "../hooks/useCollectionItems";
import useProductAPI from "../hooks/useProductAPI";

/**
 * The HTML component for all PMBoard widgets to document and visualize information.
 * @param {object} props The component props
 * @param {string} props.productId The ID of the current product.
 * @param {string} props.collectionName The name of the product collection.
 * @param {string} props.type The type of the data rows.
 * @param {string} props.evidenceColumnLabel The label for the evidence column.
 * @param {string} props.title The title to show at the top of the widget.
 * @param {string} props.mainModalId The ID of the item modal passed in `children`.
 * @param {string} props.summaryTitle The title of the summary tab on the modal.
 * @returns {React.JSX.Element} The rendered widget.
 * @example
 * &lt;Widget productId="" collectionName="" type="" title="" mainModalId="" />
 */
const Widget = ({
  productId,
  collectionName,
  type,
  evidenceColumnLabel,
  title,
  mainModalId,
  summaryTitle,
}) => {
  const data = useCollectionItems(productId, collectionName);
  const {
    addItem,
    updateItem,
    deleteItem,
    addEvidenceRecord,
    removeEvidenceRecord,
    deleteTrend,
    addTrend,
    updateTrend,
  } = useCollectionAPI(productId, collectionName);
  const { updateProductCollection } = useProductAPI();

  /**
   * @type {[WidgetDataItem[] | undefined, React.Dispatch&lt;WidgetDataItem[]>]}
   */
  const [liveData, setLiveData] = useState();

  const CREATE_DIALOG_ID = `createDialog: ${mainModalId}`;
  const NEW_NAME_FIELD_ID = `newName: ${mainModalId}`;
  const LIST_ID = `itemsTbody_${type}`;

  /**
   * @type {[Sortable | undefined, React.Dispatch&lt;Sortable>]}
   */
  const [sortable, setSortable] = useState();

  useEffect(() => {
    if (data) {
      setLiveData(data);
    }
  }, [data]);

  /**
   * @type {[WidgetDataItem | undefined, React.Dispatch&lt;WidgetDataItem>]}
   */
  const [currentWidgetItem, setCurrentWidgetItem] = useState();

  /**
   * @type {[HTMLDialogElement | undefined, React.Dispatch&lt;HTMLDialogElement | undefined>]}
   */
  const [itemModal, setItemModal] = useState();

  /**
   * @type {[HTMLDialogElement | undefined, React.Dispatch&lt;HTMLDialogElement | undefined>]}
   */
  const [createDialog, setCreateDialog] = useState();

  /**
   * Show a dialog toward the bottom of the page to create a new widget item by name.
   * @example &lt;Component onClic={() => showCreateDialog()}
   */
  const showCreateDialog = () => {
    /**
     * @type {HTMLDialogElement}
     */
    const createDialog = document.getElementById(CREATE_DIALOG_ID);
    setCreateDialog(createDialog);
    // TODO: only add once
    createDialog.addEventListener("click", (event) => {
      if (event.target === event.currentTarget) {
        createDialog.close();
      }
    });
    createDialog.showModal();
  };

  useEffect(() => {
    if (currentWidgetItem) {
      if (itemModal) {
        // TODO: track if these have been added/removed so they don't get added multiple times
        itemModal.addEventListener("click", (event) => {
          if (event.target === event.currentTarget) {
            itemModal.close();
          }
        });
        itemModal.addEventListener("close", () => {
          setItemModal(undefined);
          setCurrentWidgetItem(undefined);
        });
        itemModal.showModal();
      } else {
        /**
         * @type {HTMLDialogElement}
         */
        const modal = document.getElementById(mainModalId);
        setItemModal(modal);
      }
    }
  }, [currentWidgetItem, itemModal]);

  const [sortableContainer, setDraggableContainer] = useState();

  useEffect(() => {
    if (document.getElementById(LIST_ID) &amp;&amp; !sortableContainer) {
      setDraggableContainer(document.getElementById(LIST_ID));
    }
  });

  useEffect(() => {
    if (sortableContainer &amp;&amp; !sortable) {
      setSortable(
        new Sortable(sortableContainer, {
          draggable: "tr",
          handle: ".dragHandle",
          mirror: {
            constrainDimensions: true,
          },
          collidables: "tr",
          distance: 0,
          plugins: [Plugins.SortAnimation],
          swapAnimation: {
            duration: 200,
            easingFunction: "ease-in-out",
          },
        })
      );
    }
  }, [sortableContainer, sortable]);

  let currentDragIndex = -1;
  useEffect(() => {
    if (sortable &amp;&amp; liveData) {
      sortable.on("drag:start", (event) => {
        const trElements = Array.from(sortableContainer.childNodes);
        currentDragIndex = trElements.indexOf(event.source);
      });
      sortable.on("drag:stop", (event) => {
        const trElements = Array.from(sortableContainer.childNodes).filter(
          (tr) =>
            !tr.className.includes("draggable-mirror") &amp;&amp;
            !tr.className.includes("draggable--original")
        );
        const newIndex = trElements.indexOf(event.source);
        if (newIndex !== currentDragIndex) {
          const newData = [...liveData];
          [newData[newIndex], newData[currentDragIndex]] = [
            newData[currentDragIndex],
            newData[newIndex],
          ];
          newData.forEach((item, index) => (item.index = index));
          updateProductCollection(
            productId,
            collectionName,
            newData.map((item) => ({
              // to avoid including evidence &amp; trends in the call
              id: item.id,
              index: item.index,
              name: item.name,
              product_id: item.product_id,
            }))
          )
            .then(() => {
              // TODO: refreshing the page works, but I'd prefer not to
              // setLiveData((prevLiveData) => [...newData]); // resets the live data, but renders it the old way (!)
              window.location.reload();
            })
            .catch((err) => {
              console.error(err);
            });
        }
        // done: cleanup
        currentDragIndex = -1;
      });
    }
  }, [sortable, liveData]);

  // TODO: (above TODO) vs: this uses old `liveData` after drag reordering
  const deleteItemCallback = useCallback(
    (item) => {
      setLiveData(liveData.filter((i) => i.id !== item.id));
      deleteItem(item.id);
    },
    [liveData]
  );

  const widgetOnClickCallback = useCallback(
    (item) => {
      setCurrentWidgetItem(item);
    },
    [liveData]
  );

  return (
    &lt;>
      &lt;div
        className="panel panel-default widget"
        style={{ position: "relative", border: "1px black dashed" }}
      >
        &lt;hr
          style={{
            display: "none",
            position: "relative",
            left: "35px",
            border: "2px solid black",
            zIndex: 1000,
            width: "1000px",
            margin: 0,
          }}
        />
        &lt;div className="panel-heading">
          &lt;h3 className="panel-title">{title}&lt;/h3>
        &lt;/div>
        &lt;div className="panel-body">
          &lt;table className="table">
            &lt;thead>
              &lt;tr>
                &lt;th style={{ width: "20px" }}>&lt;/th>
                &lt;th>{type}&lt;/th>
                &lt;th>{evidenceColumnLabel}&lt;/th>
                &lt;th>Delete&lt;/th>
              &lt;/tr>
            &lt;/thead>
            &lt;tbody id={LIST_ID}>
              {liveData &amp;&amp;
                liveData
                  .sort((a, b) => a.index - b.index)
                  .map((item, index) => (
                    &lt;WidgetItemRow
                      item={item}
                      key={`WidgetItemRow #${index}`}
                      onDeleteCallback={deleteItemCallback}
                      onClickCallback={widgetOnClickCallback}
                    />
                  ))}
            &lt;/tbody>
          &lt;/table>
        &lt;/div>
        &lt;div className="panel-footer">
          &lt;button onClick={showCreateDialog}>
            &lt;span className="bi bi-person-plus" aria-hidden="true">&lt;/span> Add
          &lt;/button>
        &lt;/div>
        &lt;dialog id={CREATE_DIALOG_ID}>
          &lt;form name="createItemForm">
            &lt;p>
              New name: &lt;input type="text" id={NEW_NAME_FIELD_ID} />
            &lt;/p>
            &lt;p>
              &lt;button
                type="submit"
                onClick={async () => {
                  const newNameField =
                    document.getElementById(NEW_NAME_FIELD_ID);
                  const newName = newNameField.value;
                  const newItem = { name: newName, evidence: [] };
                  setLiveData([...liveData, newItem]);
                  await addItem(newItem);
                  createDialog.close();
                  setCreateDialog(undefined);
                  newNameField.value = "";
                }}
              >
                Create
              &lt;/button>
            &lt;/p>
          &lt;/form>
        &lt;/dialog>
      &lt;/div>
      {currentWidgetItem &amp;&amp; (
        &lt;Modal
          productId={productId}
          dialogId={mainModalId}
          item={currentWidgetItem}
          updateItemFunc={(item) => updateItem(item)}
          summaryTitle={summaryTitle}
          addEvidenceFunc={addEvidenceRecord}
          removeEvidenceFunc={removeEvidenceRecord}
          deleteTrendFunc={deleteTrend}
          addTrendFunc={addTrend}
          updateTrendFunc={updateTrend}
        />
      )}
    &lt;/>
  );
};

export default Widget;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#AddPersonaPane">AddPersonaPane</a></li><li><a href="global.html#AllTagsContext">AllTagsContext</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#Dashboard">Dashboard</a></li><li><a href="global.html#EmpathyMapPane">EmpathyMapPane</a></li><li><a href="global.html#EvidencePaneContext">EvidencePaneContext</a></li><li><a href="global.html#FileEvidencePane">FileEvidencePane</a></li><li><a href="global.html#JourneyMapPane">JourneyMapPane</a></li><li><a href="global.html#MarketResearchWidget">MarketResearchWidget</a></li><li><a href="global.html#Modal">Modal</a></li><li><a href="global.html#StakeholderEvidencePane">StakeholderEvidencePane</a></li><li><a href="global.html#StakeholderResearchWidget">StakeholderResearchWidget</a></li><li><a href="global.html#StoriesWidget">StoriesWidget</a></li><li><a href="global.html#SummaryPaneContext">SummaryPaneContext</a></li><li><a href="global.html#TodoWidget">TodoWidget</a></li><li><a href="global.html#Widget">Widget</a></li><li><a href="global.html#WidgetItemRow">WidgetItemRow</a></li><li><a href="global.html#formatTrendTypeText">formatTrendTypeText</a></li><li><a href="global.html#useCollectionAPI">useCollectionAPI</a></li><li><a href="global.html#useCollectionItems">useCollectionItems</a></li><li><a href="global.html#useEvidenceAPI">useEvidenceAPI</a></li><li><a href="global.html#useOAuthAPI">useOAuthAPI</a></li><li><a href="global.html#useProductAPI">useProductAPI</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Sat Aug 31 2024 15:59:11 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
